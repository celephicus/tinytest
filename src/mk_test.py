import re, sys, os, glob

# WARNING: I am not writing a generic "C" parser so do not go overboard on the functions. In particular keep it all 
# on one line. 'void test_foo(void)' will work just fine.
reTestFunction = re.compile(r"""
	void		# Return type void.
	\s+			# Whitespace.
	(test\w+)	# Function name .
	\s*\(		# Possible whitespace & opening bracket.
	([^)]*?)	# Possible arguments.
	\)			# Closing bracket.
	""", re.X)
reTtMacros = re.compile(r'(TT_BEGIN_FIXTURE|TT_END_FIXTURE|TT_TEST_CASE|TT_DUMP_FUNC|TT_IGNORE_FILE|TT_INCLUDE_EXTRA)(.*)')

def error(msg):
	sys.exit(msg)
	
TEST_PATTERN = 'test*.c'
files = glob.glob(TEST_PATTERN)
test_funcs = {}
test_decls, test_run, test_stubs, fixture_decls = [], [], [], []
stubnum = 0
extra_includes = []
'''
filename_strs = []
def get_fn_str(fn):
	global filename_strs
	if fn not in filename_strs:
		filename_strs.append(fn)
	return 'FN_%04d' % filename_strs.index(fn)
'''
sys.stderr.write("Scanning for files matching '%s'.\n" % TEST_PATTERN)
for fn in files: # Iterate over all files matching glob pattern.
	module = fn # os.path.basename(fn) # Form module name.
	fixture = None
	dumper = None
	num_tests = 0
	tt_module_name = None
	for lno in enumerate(open(fn).read().splitlines(), 1): # Iterate over all lines.
		lineno, ln = lno
		m = reTtMacros.search(ln)
		if m:
			macro, args = m.groups()
			args = args.strip()
			if args.startswith('('): args = args[1:]
			if args.endswith(')'): args = args[:-1]
			args = [x.strip() for x in args.split(',')]
			if macro == 'TT_IGNORE_FILE':	# Ignore the rest of this file.
				sys.stderr.write(" Ignoring file.\n")
				break
			elif macro == 'TT_BEGIN_FIXTURE':
				if len(args) != 2:
					error("Macro %s, %s, line %d requires 2 arguments." % (macro, module, lineno))
				fixture = tuple(args)
				test_run.append('tt_register_fixture(%s, %s);' % fixture)
				for funcname in fixture:
					if funcname != "NULL":
						fixture_decls.append('void %s(void);\n' % funcname)
			elif macro == 'TT_DUMP_FUNC':
				if len(args) != 1:
					error("Macro %s, %s, line %d requires 1 argument." % (macro, module, lineno))
				dumper = args[0]
				test_run.append('tinytest_set_dump(%s);' % dumper)
				if dumper != "NULL":
					fixture_decls.append('void %s(void);\n' % dumper)
			elif macro == 'TT_END_FIXTURE':
				test_run.append('tt_register_fixture(NULL, NULL);')
				fixture = None
			elif macro == 'TT_TEST_CASE': 
				# This is tricky as we might get a line like: TT_TEST_CASE(testCall, "foo", "{\"a3\"=1}", -3)

				# TODO: This breaks with a line like 'TT_TEST_CASE(testNumber, "1./,'5...", 0, 15)' with a comma in a string.
				test_func = args.pop(0)
				if test_func not in test_funcs:
					error("Macro %s, %s, line %d references an unknown test function `%s`." % (macro, module, lineno, test_func))
				test_stub_name = '%s_stub_%04d' % (test_func, stubnum)
				stubnum += 1
				test_stub_body = '%s(%s)' % (test_func, ','.join(args))
				descr =	 test_stub_body.replace(r'\"', r'\\\^').replace('"', r'\"').replace(r'\\\^', r'\\\"')
				if tt_module_name is None:
					error("Expected to have read a module name")
				test_run.append('tinytest_run_test(%s, %s, %d, "%s");' % (test_stub_name, get_fn_str(fn), lineno, descr))
				test_stubs.append('static void %s(void) { %s; }\n' % (test_stub_name, test_stub_body))
				num_tests += 1
			elif macro == 'TT_INCLUDE_EXTRA':
				extra_includes.append(args[0])
			else:
				print('***', macro, args, file=sys.stderr)
		m = reTestFunction.search(ln)
		if m:
			test_func, test_args = m.groups()
			if test_func in test_funcs:
				error("Duplicate test function %s, %s, line %d." % (test_func, module, lineno))
			if test_args in ('', 'void'):
				test_run.append('tinytest_run_test(%s, %s, %d, "%s()");' % (test_func, get_fn_str(fn), lineno, test_func))
			test_funcs[test_func] = test_args
			num_tests += 1
			
	sys.stderr.write(" Found %d test%s in %s.\n" % (num_tests, 's'[:num_tests != 1], fn))
	if fixture:
		test_run.append('tt_register_fixture(NULL, NULL);')
	if dumper:
		test_run.append('tinytest_set_dump(NULL);')
			
outfile = open('mk_test.autogen.h', 'wt')
outfile.write("""\
/* This file is autogenerated -- do not edit. */

""")
outfile.write("/* Extra include files. */\n")
for exinc in extra_includes:
	outfile.write('#include %s\n' % exinc)
outfile.write('\n')
outfile.write("/* Declare test functions. */\n")
outfile.write(''.join(['void %s(%s);\n' % x for x in test_funcs.items()]))			 
outfile.write('\n')

outfile.write("/* Declare test stubs. */\n")
outfile.write(''.join(test_stubs))			 
outfile.write('\n')

outfile.write("/* Declare fixture functions. */\n")
outfile.write(''.join(fixture_decls))			
outfile.write('\n')

outfile.write("/* Declare filenames once. */\n")
for n, fn in enumerate(filename_strs):
	outfile.write('const char* FN_%04d = "%s";\n' % (n, fn))
outfile.write('\n')

outfile.write("/* Call our test functions. */\n")
outfile.write("void runTests(void) {\n")
outfile.write(''.join(['	%s\n' % x for x in test_run]))			 
outfile.write("}\n")
outfile.write('\n')
